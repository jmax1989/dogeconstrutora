<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Pr√©dio 3D ‚Äî viewer (cores herdadas da FVS)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; }
    body { background: #0d1117; color: #c9d1d9; font-family: system-ui, sans-serif; }
    #app { position: fixed; inset: 0; }
    #hud {
      position: fixed; left: 12px; top: 12px; padding: 10px 12px;
      background: rgba(0,0,0,.45); backdrop-filter: blur(6px);
      border: 1px solid #30363d; border-radius: 10px; font-size: 14px; z-index: 10;
      display: grid; gap: 8px; width: max-content;
    }
    #hud .row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .val { width: 3.6rem; text-align: right; display: inline-block; }
    button, label { user-select: none; }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="app"></div>

  <div id="hud">
    <div class="row" id="dragHint">
      <b>Arraste</b> (esq = orbitar, dir = mover) ‚Ä¢ <b>Scroll</b> = zoom
    </div>
    <div class="row">
      <label><input id="wireOnly" type="checkbox" /> S√≥ arame</label>
      <button id="resetRot">üîÑ Resetar giro</button>
      <button id="recenter">üéØ Centralizar c√¢mera</button>
    </div>
    <div class="row">
      Opacidade: <input id="opacity" type="range" min="5" max="100" value="30" />
      <span id="opacityVal" class="val">0.30</span>
    </div>
    <div class="row">
      Explodir XY: <input id="explodeXY" type="range" min="0" max="4" step="0.01" value="0" />
      <span id="explodeXYVal" class="val">0.00</span>
    </div>
    <div class="row">
      Explodir Y (piso): <input id="explodeY" type="range" min="0" max="1.5" step="0.01" value="0" />
      <span id="explodeYVal" class="val">0.00</span>
      <button id="resetExplode">Reset</button>
    </div>
  </div>

  <!-- THREE -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
  (async function(){
    // ====== Carrega o layout do repo ======
    const LAYOUT_URL = './data/layout-3d.json';
    const layout = await fetch(LAYOUT_URL, { cache: 'no-store' }).then(r=>r.json());

    // ====== Setup ======
    const root = document.getElementById('app');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0d1117);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(devicePixelRatio);
    renderer.setSize(innerWidth, innerHeight);
    root.appendChild(renderer.domElement);

    // Luzes
    scene.add(new THREE.HemisphereLight(0xffffff, 0x222233, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5, 10, 7);
    scene.add(dir);

    // ====== Pivot / Torre ======
    const pivot = new THREE.Group();
    scene.add(pivot);
    const torre = new THREE.Group();
    pivot.add(torre);

    // ====== √ìrbita + Pan ======
    const INITIAL_RADIUS = 28;
    const INITIAL_PHI = Math.PI * 0.35;

    const orbitTarget = new THREE.Vector3(0, 8, 0);
    let radius = INITIAL_RADIUS, theta = Math.PI * 0.25, phi = INITIAL_PHI;

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const minRadius = 4, maxRadius = 200, minPhi = 0.05, maxPhi = Math.PI * 0.49;

    function updateCamera(){
      const x = orbitTarget.x + radius * Math.sin(phi) * Math.cos(theta);
      const y = orbitTarget.y + radius * Math.cos(phi);
      const z = orbitTarget.z + radius * Math.sin(phi) * Math.sin(theta);
      camera.position.set(x, y, z);
      camera.lookAt(orbitTarget);
    }
    updateCamera();

    // Controles de mouse:
    // - esquerdo = orbitar (gira pivot + inclina phi)
    // - direito  = pan (move o alvo/orbitTarget)
    let dragging=false,lastX=0,lastY=0, dragMode='orbit';
    function onDownMouse(e){
      // 0: esquerdo, 2: direito
      dragMode = (e.button === 2) ? 'pan' : 'orbit';
      dragging = true; lastX = e.clientX; lastY = e.clientY;
    }
    function onMoveMouse(e){
      if(!dragging) return;
      const dx=e.clientX-lastX, dy=e.clientY-lastY;
      lastX=e.clientX; lastY=e.clientY;

      if (dragMode === 'orbit') {
        pivot.rotation.y += dx * 0.005;
        phi -= dy * 0.005; phi = clamp(phi, minPhi, maxPhi);
        updateCamera();
      } else {
        const panScale = radius * 0.0025;
        const forward = new THREE.Vector3(); camera.getWorldDirection(forward);
        const right = new THREE.Vector3().crossVectors(forward, camera.up).normalize();
        const up = new THREE.Vector3().copy(camera.up).normalize();
        orbitTarget.addScaledVector(right, -dx * panScale);
        orbitTarget.addScaledVector(up,    dy * panScale);
        updateCamera();
      }
    }
    function onUpMouse(){ dragging=false; }

    renderer.domElement.addEventListener('mousedown', onDownMouse);
    window.addEventListener('mousemove', onMoveMouse);
    window.addEventListener('mouseup', onUpMouse);
    // bloqueia menu do bot√£o direito (para pan)
    renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());

    // Touch (1 dedo = orbitar)
    renderer.domElement.addEventListener('touchstart',e=>{
      if(e.touches.length===1){
        dragging=true; lastX=e.touches[0].clientX; lastY=e.touches[0].clientY; dragMode='orbit';
      }
    },{passive:true});
    renderer.domElement.addEventListener('touchmove',e=>{
      if(e.touches.length===1){
        onMoveMouse({ clientX:e.touches[0].clientX, clientY:e.touches[0].clientY });
      }
    },{passive:true});
    window.addEventListener('touchend',()=>{ dragging=false; });

    // Zoom
    renderer.domElement.addEventListener('wheel',e=>{
      e.preventDefault();
      const f=1+(e.deltaY>0?0.1:-0.1);
      radius=clamp(radius*f,minRadius,maxRadius);
      updateCamera();
    },{passive:false});

    // ====== Materiais (base NEUTRA cinza) ======
    let faceOpacity = 0.30;
    const NEUTRAL_HEX = 0x6e7681; // cinza base
    const makeFace = (color)=> new THREE.MeshStandardMaterial({
      color, metalness:0.0, roughness:0.9, transparent:true, opacity:faceOpacity, depthWrite:false
    });
    const makeLine = (color,width=1)=> new THREE.LineBasicMaterial({ color, linewidth:width });

const MAT = {
  face: ()=> new THREE.MeshStandardMaterial({
    color: NEUTRAL_HEX,
    metalness: 0.05,
    roughness: 0.9,
    transparent: true,
    opacity: faceOpacity,
    depthWrite: true,
    polygonOffset: true,
    polygonOffsetFactor: 1,
    polygonOffsetUnits: 1
  }),
  line: new THREE.LineBasicMaterial({
    color: 0xcad7ff,
    linewidth: 1,
    depthTest: true,
    depthWrite: false,
    transparent: true,
    opacity: 0.95
  }),
  selLine: new THREE.LineBasicMaterial({
    color: 0xffc107,
    linewidth: 2
  })
};
    const stepX = (layout.meta?.cellW ?? 1.2) + (layout.meta?.gap ?? 0.15);
    const stepZ = (layout.meta?.cellD ?? 1.2) + (layout.meta?.gap ?? 0.15);
    const aptoHeight = 0.5;
    const stepY = aptoHeight + (layout.meta?.gap ?? 0.15);

    function rectCenterX(x, w){ return x*stepX + (w*(layout.meta?.cellW??1.2) + (w-1)*(layout.meta?.gap??0.15))/2; }
    function rectCenterZ(z, d){ return z*stepZ + (d*(layout.meta?.cellD??1.2) + (d-1)*(layout.meta?.gap??0.15))/2; }

    function computeLevels(placements){
      const set = new Set(placements.map(p=>p.andar));
      const nums = [...set].filter(v => typeof v === 'number').sort((a,b)=>a-b);
      const hasAT = [...set].some(v => v === 'AT');
      if (hasAT) nums.push('AT');
      const idx = new Map(nums.map((v,i)=>[v,i]));
      return { order: nums, indexOf: (v)=>idx.get(v) };
    }

    function setFacesVisible(visible){ for (const g of torre.children) g.userData.mesh.visible = visible; }
    function setFaceOpacity(op){ faceOpacity = op; for (const g of torre.children) g.userData.mesh.material.opacity = faceOpacity; }

    // ====== Explodir ======
    let explodeXY = 0.0;
    let explodeY  = 0.0;
    function applyExplode(){
      for (const g of torre.children){
        const base = g.userData.basePos;
        const pos = base.clone();
        if (explodeXY > 0){
          const dir = new THREE.Vector3(base.x, 0, base.z);
          const len = dir.length();
          if (len > 1e-6){
            dir.multiplyScalar(1/len);
            const step = Math.max(stepX, stepZ);
            pos.addScaledVector(dir, explodeXY * step);
          }
        }
        pos.y += g.userData.levelIndex * explodeY;
        g.position.copy(pos);
      }
    }

// ===== Dimens√£o b√°sica em "mundo" =====
const cellW = (layout.meta?.cellW ?? 1.2);
const cellD = (layout.meta?.cellD ?? 1.2);
const gap   = (layout.meta?.gap   ?? 0.15);

// No viewer, a altura de um "andar" √© uniforme:
//const aptoHeight = 0.5;
//const stepX = cellW + gap;
//const stepZ = cellD + gap;
//const stepY = aptoHeight + gap;

// Centro de um ret√¢ngulo W√óD come√ßando em (x,z) em coordenadas de grade:
function rectCenterX(x, w){ return x*stepX + (w*cellW + (w-1)*gap)/2; }
function rectCenterZ(z, d){ return z*stepZ + (d*cellD + (d-1)*gap)/2; }

// ===== Voxeliza√ß√£o por APTO =====
// Gera, para cada apartamento, um Set com strings "gx,gy,gz"
// Aqui gy √© o "n√≠vel" (andar), com altura uniforme stepY
function voxelizeByApto(l){
  const byApto = new Map();
  for (const p of l.placements){
    const apt = String(p.apto);
    if (!byApto.has(apt)) byApto.set(apt, new Set());
    const set = byApto.get(apt);
    const baseY = (typeof p.andar === 'number') ? p.andar : 0; // 'AT' vira 0 aqui
    for (let gx = p.x; gx < p.x + p.w; gx++){
      for (let gz = p.z; gz < p.z + p.d; gz++){
        for (let gy = baseY; gy < baseY + p.h; gy++){
          set.add(`${gx},${gy},${gz}`);
        }
      }
    }
  }
  return byApto;
}

// ===== Meshing de fronteira (sem faces internas) =====
function buildSurfaceGeometryFromOcc(occSet){
  if (!occSet || occSet.size===0) return null;
  const has = (x,y,z)=> occSet.has(`${x},${y},${z}`);

  const pos = [];
  const idx = [];
  let vbase = 0;

  const pushQuad = (a,b,c,d)=>{
    pos.push( ...a, ...b, ...c, ...d );
    idx.push(vbase, vbase+1, vbase+2,  vbase, vbase+2, vbase+3);
    vbase += 4;
  };

  // Converte um voxel [gx,gy,gz] em coords de mundo da caixa daquele voxel
  function voxelBounds(gx,gy,gz){
    const x0 = gx * stepX, x1 = x0 + cellW;
    const z0 = gz * stepZ, z1 = z0 + cellD;
    const y0 = gy * stepY, y1 = y0 + aptoHeight;
    return {x0,x1,y0,y1,z0,z1};
  }

  // Itera por voxels; para cada uma das 6 faces, se n√£o h√° vizinho ‚Üí emite um quad
  for (const key of occSet){
    const [gx,gy,gz] = key.split(',').map(Number);
    const {x0,x1,y0,y1,z0,z1} = voxelBounds(gx,gy,gz);

    // -X
    if (!has(gx-1,gy,gz)) pushQuad([x0,y0,z1],[x0,y0,z0],[x0,y1,z0],[x0,y1,z1]);
    // +X
    if (!has(gx+1,gy,gz)) pushQuad([x1,y0,z0],[x1,y0,z1],[x1,y1,z1],[x1,y1,z0]);
    // -Z
    if (!has(gx,gy,gz-1)) pushQuad([x1,y0,z0],[x0,y0,z0],[x0,y1,z0],[x1,y1,z0]);
    // +Z
    if (!has(gx,gy,gz+1)) pushQuad([x0,y0,z1],[x1,y0,z1],[x1,y1,z1],[x0,y1,z1]);
    // -Y (piso)
    if (!has(gx,gy-1,gz)) pushQuad([x0,y0,z0],[x1,y0,z0],[x1,y0,z1],[x0,y0,z1]);
    // +Y (teto)
    if (!has(gx,gy+1,gz)) pushQuad([x0,y1,z1],[x1,y1,z1],[x1,y1,z0],[x0,y1,z0]);
  }

  if (pos.length===0) return null;

  const geom = new THREE.BufferGeometry();
  geom.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(pos), 3));
  geom.setIndex(new THREE.Uint32BufferAttribute(new Uint32Array(idx), 1));
  geom.computeVertexNormals();
  geom.computeBoundingBox(); geom.computeBoundingSphere();
  return geom;
}

// ===== Inflar para desenhar edges limpas =====
function inflateGeometry(geom, offset=0.04){
  const g = geom.clone();
  g.computeVertexNormals();
  const pos = g.getAttribute('position');
  const nor = g.getAttribute('normal');
  for (let i=0;i<pos.count;i++){
    pos.setX(i, pos.getX(i) + nor.getX(i)*offset);
    pos.setY(i, pos.getY(i) + nor.getY(i)*offset);
    pos.setZ(i, pos.getZ(i) + nor.getZ(i)*offset);
  }
  pos.needsUpdate = true;
  return g;
}    
       
    // ====== Constru√ß√£o ======
    
function buildFromLayout(l){
  while (torre.children.length) torre.remove(torre.children[0]);

  // 1) voxeliza por apartamento
  const occByApto = voxelizeByApto(l);

  // 2) para cada apto, gera uma superf√≠cie √∫nica e um grupo (mesh + edges)
  for (const [apto, occ] of occByApto.entries()){
    const surface = buildSurfaceGeometryFromOcc(occ);
    if (!surface) continue;

    // corpo transl√∫cido
    const mesh = new THREE.Mesh(surface, MAT.face());
    mesh.renderOrder = 1;

    // contorno (arestas) a partir de malha inflada
    const inflated = inflateGeometry(surface, 0.04);
    const edges = new THREE.LineSegments(new THREE.EdgesGeometry(inflated, 1), MAT.line);
    edges.renderOrder = 2;

    // calcula n√≠vel m√≠nimo do apto (para explodeY)
    let minLevel = Infinity, cx=0, cy=0, cz=0;
    // centro aproximado pelo bbox da malha
    surface.computeBoundingBox();
    const bb = surface.boundingBox;
    const center = new THREE.Vector3();
    bb.getCenter(center);
    cx = center.x; cy = center.y; cz = center.z;

    // estimar minLevel varrendo occ
    for (const key of occ){
      const gy = parseInt(key.split(',')[1],10);
      if (gy < minLevel) minLevel = gy;
    }
    if (!isFinite(minLevel)) minLevel = 0;

    const group = new THREE.Group();
    group.add(mesh); group.add(edges);
    group.position.set(0,0,0);

    // Dados para UI/cores/Explode
    group.userData = {
      apto,
      mesh, edges,
      levelIndex: minLevel,
      basePos: new THREE.Vector3(cx, cy, cz)
    };

    torre.add(group);
  }

  // 3) Centraliza conjunto
  const bbox = new THREE.Box3().setFromObject(torre);
  const center = new THREE.Vector3(); bbox.getCenter(center);
  for (const g of torre.children){
    g.position.sub(center);
    g.userData.basePos.sub(center);
  }

  applyExplode();
  recenterOrbitTarget();
  updateCamera();
}

    function recenterOrbitTarget(){
      const bbox2 = new THREE.Box3().setFromObject(torre);
      const c2 = new THREE.Vector3(); bbox2.getCenter(c2);
      orbitTarget.set(0, c2.y, 0);
    }

    buildFromLayout(layout);

    // ====== Sele√ß√£o com mira refinada ======
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    renderer.domElement.addEventListener('click', (e) => {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

      // 1) tentar nas FACES (mais preciso para sele√ß√£o por √°rea)
      const faceObjects = torre.children.map(g => g.userData.mesh);
      raycaster.setFromCamera(mouse, camera);
      let inter = raycaster.intersectObjects(faceObjects, false);

      // 2) fallback: tentar nas ARESTAS com threshold pequeno em unidade de mundo
      if (!inter.length) {
        const edgeObjects = torre.children.map(g => g.userData.edges);
        raycaster.params.Line = raycaster.params.Line || {};
        raycaster.params.Line.threshold = Math.max(stepX, stepZ) * 0.06; // ~6% do passo
        inter = raycaster.intersectObjects(edgeObjects, false);
      }

      // limpar sele√ß√£o anterior
      if (window.__SEL_GROUP__) {
        const gPrev = window.__SEL_GROUP__;
        gPrev.userData.edges.material = gPrev.__lineBackup;
        gPrev.userData.mesh.material = gPrev.__faceBackup;
        delete gPrev.__lineBackup; delete gPrev.__faceBackup;
        window.__SEL_GROUP__ = null;
      }

if (inter.length) {
  const hitObj = inter[0].object;
  const selGroup = hitObj.parent;
  if (selGroup && selGroup.userData) {
    selGroup.__lineBackup = selGroup.userData.edges.material;
    selGroup.__faceBackup = selGroup.userData.mesh.material;

    selGroup.userData.edges.material = MAT.selLine;
    // clona a face para n√£o afetar outros grupos
    const faceClone = selGroup.userData.mesh.material.clone();
    faceClone.opacity = Math.min(1, faceOpacity + 0.2);
    selGroup.userData.mesh.material = faceClone;

    window.__SEL_GROUP__ = selGroup;
    console.log('Selecionado:', selGroup.userData.apto);
  }
}
    });

    // ====== UI ======
    const opacity = document.getElementById('opacity');
    const opacityVal = document.getElementById('opacityVal');
    opacity.addEventListener('input', () => {
      const v = parseInt(opacity.value, 10)/100;
      opacityVal.textContent = v.toFixed(2);
      setFaceOpacity(v);
    });
    document.getElementById('wireOnly').addEventListener('change', (e) => setFacesVisible(!e.target.checked));
    const explodeXYRange = document.getElementById('explodeXY');
    const explodeXYVal = document.getElementById('explodeXYVal');
    explodeXYRange.addEventListener('input', () => {
      explodeXY = parseFloat(explodeXYRange.value);
      explodeXYVal.textContent = explodeXY.toFixed(2);
      applyExplode();
    });
    const explodeYRange = document.getElementById('explodeY');
    const explodeYVal = document.getElementById('explodeYVal');
    explodeYRange.addEventListener('input', () => {
      explodeY = parseFloat(explodeYRange.value);
      explodeYVal.textContent = explodeY.toFixed(2);
      applyExplode();
    });
    document.getElementById('resetExplode').addEventListener('click', () => {
      explodeXY = 0; explodeY = 0;
      explodeXYRange.value = '0'; explodeYRange.value = '0';
      explodeXYVal.textContent = '0.00'; explodeYVal.textContent = '0.00';
      applyExplode();
    });
    document.getElementById('resetRot').addEventListener('click', () => { pivot.rotation.set(0,0,0); });
    document.getElementById('recenter').addEventListener('click', () => {
      recenterOrbitTarget(); radius = INITIAL_RADIUS; phi = INITIAL_PHI; updateCamera();
    });

    // Estado inicial
    setFaceOpacity(parseInt(opacity.value,10)/100);
    setFacesVisible(true);

    // ====== Cores herdadas do 2D ======
    function normApto(s){
      if (s == null) return '';
      let t = String(s).trim().toUpperCase();
      t = t.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
      t = t.replace(/\b(APARTAMENTO|APTO|AP|APT|APART)\b\.?/g, '');
      t = t.replace(/[\s\-\._\/]/g, '');
      return t;
    }
    function aplicarCoresFVS(payload){
      if (!payload) return;
      const defHex = (payload.default || '#6e7681').trim();
      const map = payload.colors || {};
      for (const g of torre.children){
        const id = g.userData.apto;
        const hex = map[id] || map[normApto(id)] || null;
        const color = new THREE.Color(hex || defHex);
        g.userData.mesh.material.color.copy(color);
        g.userData.mesh.material.needsUpdate = true;
      }
    }
    window.addEventListener('message', (e)=>{
      const data = e.data || {};
      if (data.type === 'fvsColorMap') {
        aplicarCoresFVS(data.payload);
      }
    });
    // handshake opcional: pede o mapa ao abrir via iframe
    try { parent.postMessage({ type: 'ready-3d' }, '*'); } catch(_) {}

    // ====== Resize & Loop ======
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      updateCamera();
    });

    (function animate(){ requestAnimationFrame(animate); renderer.render(scene, camera); })();
  })();
  </script>
</body>
</html>


